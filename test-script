--// LocalScript (StarterPlayerScripts)
-- Full automation (ONE keybind: P):
--
-- For each pack in this exact order:
--  1) Slime (Emerald)
--  2) Note (Emerald)
--  3) Sins (Emerald)
--  4) Fairy (Emerald)
--  5) Bizarre (Emerald)
--  6) Geass (Emerald)
--
-- Flow per pack:
--   Press hotbar number (1-6) to select/equip the pack
--   place (zigzag sweep) -> wait 3s -> if models exist:
--       potions (40) -> teleport to each model and press E -> repeat
--
-- Failsafe logic:
--   After a placement sweep completes, start a 30s countdown window.
--   If NO placed-pack models are found for 30s:
--      - Press the SAME hotbar number and try again (because you might have unequipped)
--      - If it fails again (2nd 30s window), assume you're out of that pack -> proceed to next pack
--   Final failsafe:
--      - On pack #6 (hotbar 6), require 3 consecutive 30s failures before stopping the whole loop.

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local VirtualInputManager = game:GetService("VirtualInputManager")

local player = Players.LocalPlayer

-- Remotes
local Remotes = ReplicatedStorage:WaitForChild("Remotes")
local cardPack = Remotes:WaitForChild("Card")
local potionRemote = Remotes:WaitForChild("Potion")

-- === QUAD CORNERS ===
-- B(top-left) -> C(top-right) -> D(bottom-right) -> A(bottom-left)
local A = Vector3.new(-622.432373, 7.22039652, -92.1760025)
local B = Vector3.new(-621.693604, 7.1538558,  -150.819366)
local C = Vector3.new(-570.654053, 7.1538558,  -152.937439)
local D = Vector3.new(-570.425293, 7.1538558,  -93.1411057)

-- === PACK ORDER + HOTBAR KEYS (EXACT ORDER REQUIRED) ===
local PACK_SEQUENCE = {
	"Slime-Emerald",
	"Note-Emerald",
	"Sins-Emerald",
	"Fairy-Emerald",
	"Bizarre-Emerald",
	"Geass-Emerald",
}

local HOTBAR_KEYS = {
	Enum.KeyCode.One,
	Enum.KeyCode.Two,
	Enum.KeyCode.Three,
	Enum.KeyCode.Four,
	Enum.KeyCode.Five,
	Enum.KeyCode.Six,
}

-- === TUNING (keep same settings) ===
local STEP_STUDS = 7.0
local ROW_STEP_STUDS = 7.0
local Y_LIFT = 2.5
local TELEPORT_WAIT = 0.08
local PLACE_EVERY_N_STEPS = 1
local PLACE_COOLDOWN = 0.08

local AFTER_PLACE_WAIT = 3.0

local POTION_NAME = "HatchTime1"
local POTION_USES = 40
local POTION_DELAY = 0.10

local OPEN_KEY = Enum.KeyCode.E
local OPEN_AFTER_TELEPORT_DELAY = 0.12
local BETWEEN_PACKS_DELAY = 0.05
local OPEN_PRESS_DURATION = 0.05

-- Failsafe windows
local NO_MODEL_TIMEOUT = 30.0

-- Plot path
local PLOTS_FOLDER_NAME = "Plots"
local PLOT_ID_FOLDER_NAME = "1"
local PLACED_PACKS_FOLDER_NAME = "Packs"

-- Toggle key
local TOGGLE_KEY = Enum.KeyCode.P

-- =========================
-- Helpers
-- =========================
local function getCharacterParts()
	local char = player.Character or player.CharacterAdded:Wait()
	local hrp = char:WaitForChild("HumanoidRootPart", 5)
	local hum = char:FindFirstChildOfClass("Humanoid")
	return char, hrp, hum
end

local function v3Lerp(a, b, t)
	return a + (b - a) * t
end

local function stepsForDistance(dist, step)
	return math.max(1, math.floor(dist / step + 0.5))
end

local function teleportTo(hrp, pos, lookDir)
	local p = pos + Vector3.new(0, Y_LIFT, 0)
	if lookDir and lookDir.Magnitude > 1e-6 then
		hrp.CFrame = CFrame.lookAt(p, p + lookDir.Unit)
	else
		hrp.CFrame = CFrame.new(p)
	end
end

local function pressKey(keyCode, holdSeconds)
	VirtualInputManager:SendKeyEvent(true, keyCode, false, game)
	task.wait(holdSeconds or 0.03)
	VirtualInputManager:SendKeyEvent(false, keyCode, false, game)
end

local function selectHotbar(slotIndex)
	local key = HOTBAR_KEYS[slotIndex]
	if key then
		pressKey(key, 0.03)
	end
end

local function getPlacedPacksFolder()
	local plots = Workspace:FindFirstChild(PLOTS_FOLDER_NAME)
	if not plots then return nil end
	local plot = plots:FindFirstChild(PLOT_ID_FOLDER_NAME)
	if not plot then return nil end
	return plot:FindFirstChild(PLACED_PACKS_FOLDER_NAME)
end

local function getPlacedPackModels()
	local folder = getPlacedPacksFolder()
	if not folder then return {} end

	local models = {}
	for _, child in ipairs(folder:GetChildren()) do
		if child:IsA("Model") then
			table.insert(models, child)
		end
	end
	return models
end

local function getModelWorldPos(model: Model): Vector3?
	if not model or not model:IsA("Model") then return nil end

	local ok, pivot = pcall(function()
		return model:GetPivot()
	end)
	if ok and pivot then
		return pivot.Position
	end

	if model.PrimaryPart then
		return model.PrimaryPart.Position
	end

	local bp = model:FindFirstChildWhichIsA("BasePart", true)
	return bp and bp.Position or nil
end

-- =========================
-- Actions
-- =========================
local currentPackName = PACK_SEQUENCE[1]

local function placePack()
	-- Uses the current pack name (rotates through PACK_SEQUENCE)
	cardPack:FireServer("Place", currentPackName)
end

local function applyPotions(runningFlag)
	for i = 1, POTION_USES do
		if not runningFlag() then return false end
		potionRemote:FireServer("Apply", POTION_NAME)
		if POTION_DELAY > 0 then
			task.wait(POTION_DELAY)
		end
	end
	return true
end

local function openModels(models, runningFlag)
	local _, hrp = getCharacterParts()
	if not hrp then
		warn("[Loop] No HumanoidRootPart found.")
		return false
	end

	-- Greedy nearest-first ordering (less travel)
	local function distToHRP(m)
		local p = getModelWorldPos(m)
		if not p then return math.huge end
		return (p - hrp.Position).Magnitude
	end

	local remaining = table.clone(models)
	local ordered = {}

	while #remaining > 0 do
		if not runningFlag() then return false end
		table.sort(remaining, function(m1, m2)
			return distToHRP(m1) < distToHRP(m2)
		end)
		table.insert(ordered, table.remove(remaining, 1))
	end

	for _, model in ipairs(ordered) do
		if not runningFlag() then return false end
		local pos = getModelWorldPos(model)
		if pos then
			local lookDir = (pos - hrp.Position)
			teleportTo(hrp, pos, lookDir)

			task.wait(OPEN_AFTER_TELEPORT_DELAY)
			pressKey(OPEN_KEY, OPEN_PRESS_DURATION)

			if BETWEEN_PACKS_DELAY > 0 then
				task.wait(BETWEEN_PACKS_DELAY)
			end
		end
	end

	return true
end

-- =========================
-- Placement sweep (one full zigzag pass)
-- Returns true if completed, false if stopped mid-way
-- =========================
local function zigzagPlaceSweep(runningFlag)
	local _, hrp = getCharacterParts()
	if not hrp then
		warn("[Loop] No HumanoidRootPart found.")
		return false
	end

	local topLen = (C - B).Magnitude
	local leftLen = (A - B).Magnitude
	local cols = stepsForDistance(topLen, STEP_STUDS)
	local rows = stepsForDistance(leftLen, ROW_STEP_STUDS)

	local globalStep = 0
	local nextPlaceTime = 0

	for r = 0, rows do
		if not runningFlag() then return false end

		local rt = r / rows
		local rowStart = v3Lerp(B, A, rt)
		local rowEnd   = v3Lerp(C, D, rt)
		local rowDir = (rowEnd - rowStart)
		local leftToRight = (r % 2 == 0)

		for c = 0, cols do
			if not runningFlag() then return false end

			local ct = c / cols
			local t = leftToRight and ct or (1 - ct)
			local pos = v3Lerp(rowStart, rowEnd, t)

			teleportTo(hrp, pos, rowDir)

			if TELEPORT_WAIT > 0 then
				task.wait(TELEPORT_WAIT)
			end

			globalStep += 1
			if (globalStep % PLACE_EVERY_N_STEPS) == 0 then
				local now = os.clock()
				if now >= nextPlaceTime then
					placePack()
					nextPlaceTime = now + PLACE_COOLDOWN
				end
			end
		end
	end

	return true
end

-- =========================
-- Main state machine
-- =========================
local running = false
local loopThread = nil

local function isRunning()
	return running
end

local function runPackLoop(packIndex)
	-- For packs 1-5: 2 consecutive failures to move on
	-- For pack 6: 3 consecutive failures to stop everything
	local maxFailures = (packIndex == 6) and 3 or 2

	currentPackName = PACK_SEQUENCE[packIndex]
	print(string.format("[Loop] === PACK %d/%d: %s ===", packIndex, #PACK_SEQUENCE, currentPackName))

	local failures = 0

	while running and failures < maxFailures do
		-- Press hotbar key BEFORE trying (and again each retry)
		selectHotbar(packIndex)
		task.wait(0.05)

		print(string.format("[Loop] Using hotbar #%d -> %s | Attempt %d/%d",
			packIndex, currentPackName, failures + 1, maxFailures
		))

		-- We'll keep cycling place->wait->check.
		-- The 30s failsafe window is measured from AFTER each placement sweep.
		local failsafeStartTime = nil

		while running do
			-- 1) Place sweep
			local ok = zigzagPlaceSweep(isRunning)
			if not ok then return false end

			-- Arm countdown AFTER placing completes
			failsafeStartTime = os.clock()

			-- 2) Wait 3s
			local startWait = os.clock()
			while running and (os.clock() - startWait) < AFTER_PLACE_WAIT do
				task.wait(0.1)
			end
			if not running then return false end

			-- 3) Check models
			local models = getPlacedPackModels()

			if #models == 0 then
				local elapsed = os.clock() - failsafeStartTime
				print(string.format("[Loop] No models found (%.1fs / %.0fs) for pack %d",
					elapsed, NO_MODEL_TIMEOUT, packIndex
				))

				if elapsed >= NO_MODEL_TIMEOUT then
					-- This counts as a failure for THIS pack selection.
					failures += 1
					print(string.format("[Loop] FAILSAFE HIT for pack %d (%d/%d).",
						packIndex, failures, maxFailures
					))
					-- Break to retry (press hotbar again) or move on to next pack
					break
				end

				-- Keep cycling quickly (don’t hard-spin)
				task.wait(0.2)
			else
				-- Found models -> do potions + open, and continue placing this same pack
				print(string.format("[Loop] Found %d models -> Potions(40) then Open.", #models))

				local okPotions = applyPotions(isRunning)
				if not okPotions then return false end

				-- Re-fetch models (they might change)
				models = getPlacedPackModels()
				if #models > 0 then
					local okOpen = openModels(models, isRunning)
					if not okOpen then return false end
				else
					print("[Loop] After potions, no models present (skipping open).")
				end

				-- Small stability pause between cycles on success
				task.wait(0.25)
				-- Note: failures is NOT incremented here; we only fail when 30s window hits with zero models.
			end
		end
	end

	-- If we exhausted failures, return "depleted"
	return true
end

local function mainLoop()
	print("[Loop] Started. (Press P to stop)")

	for packIndex = 1, #PACK_SEQUENCE do
		if not running then break end

		local depletedOrStopped = runPackLoop(packIndex)
		if not running then break end

		-- After finishing pack 1-5, proceed to next.
		-- After pack 6, if we hit maxFailures (3), stop loop entirely.
		if packIndex == 6 then
			-- If we reached here, we exhausted the final pack’s attempts
			warn("[Loop] Final failsafe reached after pack #6 attempts. Stopping loop.")
			running = false
			break
		else
			print(string.format("[Loop] Moving to next pack (finished attempts for pack %d).", packIndex))
		end
	end

	print("[Loop] Stopped.")
end

local function toggle()
	running = not running
	print("[Loop] Running:", running)

	if running then
		loopThread = task.spawn(mainLoop)
	end
end

UserInputService.InputBegan:Connect(function(input, gp)
	if gp then return end
	if input.KeyCode == TOGGLE_KEY then
		toggle()
	end
end)

print("[Loaded] Press P to start/stop the full pack-rotation loop.")
