--// LocalScript (StarterPlayerScripts)
-- MERGED:
-- 1) Token collector (always-on)
-- 2) Pack scanner/buyer (always-on) with DEBUG_SCANNER toggle
-- 3) Pack placer/opener loop (toggle P)
--
-- NEW:
--  - Weather-based potion counts
--    Scan weather before loop starts, then rescan after packs are placed (models detected).
--    Only apply weather potion counts if weather persists (same in both scans).

--========================
-- Services
--========================
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local VirtualInputManager = game:GetService("VirtualInputManager")

local player = Players.LocalPlayer
local Remotes = ReplicatedStorage:WaitForChild("Remotes")

--========================
-- Remotes
--========================
local CardRemote = Remotes:WaitForChild("Card")
local PotionRemote = Remotes:WaitForChild("Potion")

--========================
-- DEBUG TOGGLES
--========================
local DEBUG_SCANNER = false -- set true when you want scanner prints

--========================
-- Shared Helpers
--========================
local function pressKey(keyCode: Enum.KeyCode, holdSeconds: number?)
	VirtualInputManager:SendKeyEvent(true, keyCode, false, game)
	task.wait(holdSeconds or 0.03)
	VirtualInputManager:SendKeyEvent(false, keyCode, false, game)
end

local function getCharacterParts()
	local char = player.Character or player.CharacterAdded:Wait()
	local hrp = char:WaitForChild("HumanoidRootPart", 5)
	local hum = char:FindFirstChildOfClass("Humanoid")
	return char, hrp, hum
end

local function v3Lerp(a: Vector3, b: Vector3, t: number)
	return a + (b - a) * t
end

local function stepsForDistance(dist: number, step: number)
	return math.max(1, math.floor(dist / step + 0.5))
end

local function getModelWorldPos(model: Model): Vector3?
	if not model or not model:IsA("Model") then return nil end

	local ok, pivot = pcall(function()
		return model:GetPivot()
	end)
	if ok and pivot then
		return pivot.Position
	end

	if model.PrimaryPart then
		return model.PrimaryPart.Position
	end

	local bp = model:FindFirstChildWhichIsA("BasePart", true)
	return bp and bp.Position or nil
end

--========================
-- SECTION 1: TOKEN COLLECTOR (always-on)
--========================
do
	local COLLECT_COOLDOWN = 10 * 60

	task.spawn(function()
		while true do
			PotionRemote:FireServer("Collect", "TravelToken1")
			PotionRemote:FireServer("Collect", "TravelToken2")
			PotionRemote:FireServer("Collect", "Luck")
			PotionRemote:FireServer("Collect", "HatchTime")

			task.wait(5)
			task.wait(COLLECT_COOLDOWN)
		end
	end)
end

--========================
-- SECTION 2: PACK SCANNER/BUYER (always-on, debug-toggle prints)
--========================
do
	local clientFolder = Workspace:WaitForChild("Client")
	local packsFolder = clientFolder:WaitForChild("Packs")

	local function sPrint(...)
		if DEBUG_SCANNER then print(...) end
	end

	sPrint("[Scanner] Connected to:", packsFolder:GetFullName())

	local ALWAYS_BUY = {
		Pirate = true,
		Ninja = true,
		Soul = true,
		Dragon = true,
		Sorcerer = true,
		Slayer = true,
		Fire = true,
		Hero = true,
		Hunter = true,

		-- Newest Packs
		Mage = true,
		Zero = true,
	}

	local DIAMOND_ONLY = {
		Flight = true,
		Chainsaw = true,
		Titan = true,
		Solo = true
	}

	local MUTATION_REQUIRED = {
		Slime = true,
		Note = true,
		Sins = true,
		Fairy = true,
		Bizarre = true,
		Geass = true,
	}

	local function buyPack(modelName: string)
		CardRemote:FireServer("BuyPack", modelName)
	end

	local function scanForMutation(model: Model)
		sPrint("  > Scanning model:", model.Name)

		for _, descendant in ipairs(model:GetDescendants()) do
			if descendant:IsA("MeshPart") and descendant.Name ~= "Top" and descendant.Name ~= "Bottom" then
				sPrint("     [IDENTITY MESH] ->", descendant.Name)

				local hasRainbow, hasDiamond, hasEmerald, hasVoid = false, false, false, false

				for _, child in ipairs(descendant:GetChildren()) do
					if child:IsA("Part") then
						sPrint("        Mutation Found ->", child.Name)

						if child.Name == "Rainbow" then hasRainbow = true
						elseif child.Name == "Diamond" then hasDiamond = true
						elseif child.Name == "Emerald" then hasEmerald = true
						elseif child.Name == "Void" then hasVoid = true end
					end
				end

				if hasRainbow then buyPack(model.Name); return end
				if ALWAYS_BUY[descendant.Name] then buyPack(model.Name); return end

				if DIAMOND_ONLY[descendant.Name] then
					if hasDiamond then buyPack(model.Name) end
					return
				end

				if MUTATION_REQUIRED[descendant.Name] then
					if hasDiamond or hasEmerald or hasVoid then
						buyPack(model.Name)
					end
					return
				end

				return
			end
		end
	end

	for _, child in ipairs(packsFolder:GetChildren()) do
		if child:IsA("Model") then
			scanForMutation(child)
		end
	end

	packsFolder.ChildAdded:Connect(function(child)
		if child:IsA("Model") then
			scanForMutation(child)
		end
	end)
end

--========================
-- SECTION 3: PACK PLACER + OPENER LOOP (toggle P only, verbose)
--========================
do
	-- === QUAD CORNERS ===
	local QA = Vector3.new(-622.432373, 7.22039652, -92.1760025)
	local QB = Vector3.new(-621.693604, 7.1538558,  -150.819366)
	local QC = Vector3.new(-570.654053, 7.1538558,  -152.937439)
	local QD = Vector3.new(-570.425293, 7.1538558,  -93.1411057)

	-- Pack names
	local PACK_SEQUENCE = {
		"Zero-Gold",
		"Mage-Gold",
		"Zero-Emerald",
		"Mage-Emerald",
	}

	-- === TUNING ===
	local STEP_STUDS = 7.0
	local ROW_STEP_STUDS = 7.0
	local Y_LIFT = 2.5
	local TELEPORT_WAIT = 0.08
	local PLACE_EVERY_N_STEPS = 1
	local PLACE_COOLDOWN = 0.08
	local AFTER_PLACE_WAIT = 3.0

	--========================
	-- Potions (two-phase + weather mapping)
	--========================
	local POTION_DELAY = 0.10

	local HATCH2_NAME = "HatchTime2"
	local DEFAULT_HATCH2_USES = 1

	local HATCH1_NAME = "HatchTime1"
	local DEFAULT_HATCH1_USES = 39

	-- Customize per-weather counts here (set nil or omit to use defaults)
	-- Names must match the Weather Part name exactly:
	-- Rain / Thunderstorm / Snow / Sandstorm / Heatwave / Blood Moon
	local WEATHER_POTIONS = {
	-- Rain: no reduction; use both default values -> (no entry needed)

	Thunderstorm = { hatch1 = 31 }, -- hatch2 uses DEFAULT
	Snow         = { hatch1 = 35 }, -- hatch2 uses DEFAULT
	Sandstorm    = { hatch1 = 33 }, -- hatch2 uses DEFAULT
	Heatwave     = { hatch1 = 29 }, -- hatch2 uses DEFAULT

	["Blood Moon"] = { hatch2 = 0, hatch1 = 22 }, -- NO hatch2s, hatch1=22
}

	-- Open packs
	local OPEN_KEY = Enum.KeyCode.E
	local OPEN_AFTER_TELEPORT_DELAY = 0.12
	local BETWEEN_PACKS_DELAY = 0.05
	local OPEN_PRESS_DURATION = 0.05

	-- Failsafe tuning
	local NO_MODEL_TIMEOUT = 20.0
	local FAILS_PER_PACK = 2

	-- Post-open drain
	local POST_OPEN_MAX_PASSES = 12
	local POST_OPEN_PASS_PAUSE = 0.15
	local POST_OPEN_STUCK_LIMIT = 2

	-- Keybinds
	local TOGGLE_KEY = Enum.KeyCode.P
	local SKIP_KEY = Enum.KeyCode.L

	-- Placed packs folder path
	local PLOTS_FOLDER_NAME = "Plots"
	local PLOT_ID_FOLDER_NAME = "1"
	local PLACED_PACKS_FOLDER_NAME = "Packs"

	--========================
	-- Weather reader
	--========================
	local function getWeatherName(): string?
		local vfx = Workspace:FindFirstChild("VFX")
		if not vfx then return nil end

		local weatherFolder = vfx:FindFirstChild("Weather")
		if not weatherFolder then return nil end

		local part = weatherFolder:FindFirstChild("Part")
		if not part or not part:IsA("BasePart") then return nil end

		local name = part.Name
		if name and name ~= "" then
			return name
		end
		return nil
	end

	local function getPotionCountsForWeather(persistedWeather: string?)
		-- defaults
		local h2 = DEFAULT_HATCH2_USES
		local h1 = DEFAULT_HATCH1_USES

		if persistedWeather then
			local cfg = WEATHER_POTIONS[persistedWeather]
			if cfg then
				if cfg.hatch2 ~= nil then h2 = cfg.hatch2 end
				if cfg.hatch1 ~= nil then h1 = cfg.hatch1 end
			end
		end

		return h2, h1
	end

	-- State
	local running = false
	local currentPackName = PACK_SEQUENCE[1]
	local skipRequested = false
	local currentPackIndex = 1

	-- NEW: weather scanned once at loop start
	local loopStartWeather: string? = nil

	local function teleportTo(hrp: BasePart, pos: Vector3, lookDir: Vector3?)
		local p = pos + Vector3.new(0, Y_LIFT, 0)
		if lookDir and lookDir.Magnitude > 1e-6 then
			hrp.CFrame = CFrame.lookAt(p, p + lookDir.Unit)
		else
			hrp.CFrame = CFrame.new(p)
		end
	end

	local function getPlacedPacksFolder()
		local plots = Workspace:FindFirstChild(PLOTS_FOLDER_NAME)
		if not plots then return nil end
		local plot = plots:FindFirstChild(PLOT_ID_FOLDER_NAME)
		if not plot then return nil end
		return plot:FindFirstChild(PLACED_PACKS_FOLDER_NAME)
	end

	local function getPlacedPackModels()
		local folder = getPlacedPacksFolder()
		if not folder then return {} end
		local models = {}
		for _, child in ipairs(folder:GetChildren()) do
			if child:IsA("Model") then
				table.insert(models, child)
			end
		end
		return models
	end

	local function placeCurrentPack()
		CardRemote:FireServer("Place", currentPackName)
	end

	-- Updated: applyPotions now takes dynamic counts
	local function applyPotions(h2Uses: number, h1Uses: number)
		for i = 1, h2Uses do
			if not running or skipRequested then return false end
			PotionRemote:FireServer("Apply", HATCH2_NAME)
			if POTION_DELAY > 0 then task.wait(POTION_DELAY) end
		end

		for i = 1, h1Uses do
			if not running or skipRequested then return false end
			PotionRemote:FireServer("Apply", HATCH1_NAME)
			if POTION_DELAY > 0 then task.wait(POTION_DELAY) end
		end

		return true
	end

	local function openModels(models: {Model})
		local _, hrp = getCharacterParts()
		if not hrp then
			warn("[Loop] No HumanoidRootPart found.")
			return false
		end

		local function distToHRP(m: Model)
			local p = getModelWorldPos(m)
			if not p then return math.huge end
			return (p - hrp.Position).Magnitude
		end

		local remaining = table.clone(models)
		local ordered = {}
		while #remaining > 0 do
			if not running or skipRequested then return false end
			table.sort(remaining, function(m1, m2)
				return distToHRP(m1) < distToHRP(m2)
			end)
			table.insert(ordered, table.remove(remaining, 1))
		end

		for _, model in ipairs(ordered) do
			if not running or skipRequested then return false end
			local pos = getModelWorldPos(model)
			if pos then
				local _, hrp2 = getCharacterParts()
				if not hrp2 then return false end

				local lookDir = (pos - hrp2.Position)
				teleportTo(hrp2, pos, lookDir)

				task.wait(OPEN_AFTER_TELEPORT_DELAY)
				pressKey(OPEN_KEY, OPEN_PRESS_DURATION)

				if BETWEEN_PACKS_DELAY > 0 then
					task.wait(BETWEEN_PACKS_DELAY)
				end
			end
		end

		return true
	end

	local function openUntilFolderEmpty()
		local stuck = 0
		local lastCount = math.huge

		for pass = 1, POST_OPEN_MAX_PASSES do
			if not running or skipRequested then return false end

			local models = getPlacedPackModels()
			local count = #models

			print(string.format("[Loop] Post-open scan pass %d: %d models remaining", pass, count))

			if count == 0 then
				return true
			end

			if count >= lastCount then
				stuck += 1
				if stuck >= POST_OPEN_STUCK_LIMIT then
					warn("[Loop] Post-open appears stuck (models not decreasing). Continuing loop anyway.")
					return true
				end
			else
				stuck = 0
			end
			lastCount = count

			local ok = openModels(models)
			if not ok then return false end

			task.wait(POST_OPEN_PASS_PAUSE)
		end

		warn("[Loop] Post-open max passes reached. Continuing loop.")
		return true
	end

	local function zigzagPlaceSweep()
		local _, hrp = getCharacterParts()
		if not hrp then
			warn("[Loop] No HumanoidRootPart found.")
			return false
		end

		local topLen = (QC - QB).Magnitude
		local leftLen = (QA - QB).Magnitude
		local cols = stepsForDistance(topLen, STEP_STUDS)
		local rows = stepsForDistance(leftLen, ROW_STEP_STUDS)

		local globalStep = 0
		local nextPlaceTime = 0

		for r = 0, rows do
			if not running or skipRequested then return false end

			local rt = r / rows
			local rowStart = v3Lerp(QB, QA, rt)
			local rowEnd   = v3Lerp(QC, QD, rt)
			local rowDir = (rowEnd - rowStart)
			local leftToRight = (r % 2 == 0)

			for c = 0, cols do
				if not running or skipRequested then return false end

				local ct = c / cols
				local t = leftToRight and ct or (1 - ct)
				local pos = v3Lerp(rowStart, rowEnd, t)

				teleportTo(hrp, pos, rowDir)

				if TELEPORT_WAIT > 0 then
					task.wait(TELEPORT_WAIT)
				end

				globalStep += 1
				if (globalStep % PLACE_EVERY_N_STEPS) == 0 then
					local now = os.clock()
					if now >= nextPlaceTime then
						placeCurrentPack()
						nextPlaceTime = now + PLACE_COOLDOWN
					end
				end
			end
		end

		return true
	end

	local function attemptWindowForModels()
		local windowStart = os.clock()

		while running do
			if skipRequested then
				return false
			end

			if (os.clock() - windowStart) >= NO_MODEL_TIMEOUT then
				return false
			end

			local okSweep = zigzagPlaceSweep()
			if not okSweep then return false end

			local startWait = os.clock()
			while running and (os.clock() - startWait) < AFTER_PLACE_WAIT do
				if skipRequested then return false end
				task.wait(0.1)
			end
			if not running or skipRequested then return false end

			local models = getPlacedPackModels()
			if #models > 0 then
				return true
			end

			task.wait(0.2)
		end

		return false
	end

	local function mainLoop()
		loopStartWeather = getWeatherName()
		if loopStartWeather then
			print("[Weather] Detected at loop start:", loopStartWeather)
		else
			print("[Weather] None at loop start.")
		end

		print("[Loop] Started. (Press P to stop)  |  Press L to skip current pack")

		for packIndex = 1, #PACK_SEQUENCE do
			if not running then break end

			currentPackIndex = packIndex
			currentPackName = PACK_SEQUENCE[packIndex]
			print(string.format("[Loop] === PACK %d/%d: %s ===", packIndex, #PACK_SEQUENCE, currentPackName))

			local failures = 0
			local equippedConfirmed = false

			while running and failures < FAILS_PER_PACK do
				if skipRequested then
					print("[Loop] Skip requested -> moving to next pack.")
					skipRequested = false
					break
				end

				if not equippedConfirmed then
					pressKey(Enum.KeyCode.One, 0.03)
					task.wait(0.05)
				end

				print(string.format("[Loop] Attempt %d/%d (%.0fs window) for %s",
					failures + 1, FAILS_PER_PACK, NO_MODEL_TIMEOUT, currentPackName
				))

				local foundModels = attemptWindowForModels()
				if not running then break end

				if skipRequested then
					print("[Loop] Skip requested -> moving to next pack.")
					skipRequested = false
					break
				end

				if not foundModels then
					failures += 1
					equippedConfirmed = false
					warn(string.format("[Loop] FAILSAFE HIT: no models in %.0fs for %s (%d/%d)",
						NO_MODEL_TIMEOUT, currentPackName, failures, FAILS_PER_PACK
					))
					task.wait(0.25)
				else
					equippedConfirmed = true

					-- Weather rescan AFTER packs are placed and detected
					local secondWeather = getWeatherName()
					local useWeather: string? = nil

					if loopStartWeather and secondWeather == loopStartWeather then
						useWeather = loopStartWeather
						print("[Weather] Persisted:", useWeather, "-> using weather potion counts")
					else
						if loopStartWeather then
							print("[Weather] Changed/ended (start=", tostring(loopStartWeather), " now=", tostring(secondWeather), ") -> using DEFAULT potion counts")
						else
							-- no weather at start, use defaults
							-- (even if weather appears later, your rule says only use weather if found at first scan and persists)
							-- if you ever want "weather appears later => use it", tell me.
						end
					end

					local h2Uses, h1Uses = getPotionCountsForWeather(useWeather)
					print(string.format("[Loop] Potion plan: HatchTime2 x%d, HatchTime1 x%d", h2Uses, h1Uses))

					print(string.format("[Loop] Models found for %s -> Potions then Open+Drain.", currentPackName))

					local okPotions = applyPotions(h2Uses, h1Uses)
					if not okPotions or not running then break end
					if skipRequested then
						print("[Loop] Skip requested during potions -> moving to next pack.")
						skipRequested = false
						break
					end

					local okDrain = openUntilFolderEmpty()
					if not okDrain or not running then break end
					if skipRequested then
						print("[Loop] Skip requested during open -> moving to next pack.")
						skipRequested = false
						break
					end

					failures = 0
					task.wait(0.25)
				end
			end

			if not running then break end
			print(string.format("[Loop] Moving on from %s.", currentPackName))
		end

		warn("[Loop] Completed all packs or stopped. Stopping loop.")
		running = false
		print("[Loop] Stopped.")
	end

	local function toggle()
		running = not running
		print("[Loop] Running:", running)

		if running then
			skipRequested = false
			task.spawn(mainLoop)
		else
			skipRequested = false
		end
	end

	UserInputService.InputBegan:Connect(function(input, gp)
		if gp then return end

		if input.KeyCode == TOGGLE_KEY then
			toggle()
			return
		end

		if input.KeyCode == SKIP_KEY then
			if running then
				print(string.format("[Loop] Skip key pressed (L) -> will skip pack %d (%s).", currentPackIndex, tostring(currentPackName)))
				skipRequested = true
			end
			return
		end
	end)

	print("[Loop] Loaded. Press P to start/stop. Press L to skip current pack.")
end

print("[Merged] Loaded: Tokens + Scanner always-on. Pack loop toggles with P. (Scanner debug:", DEBUG_SCANNER, ")")
